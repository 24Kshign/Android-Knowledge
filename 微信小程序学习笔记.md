
## 微信小程序学习笔记

### 学习网站

#### [微信小程序简易教程（官网）](https://developers.weixin.qq.com/miniprogram/dev/)
#### [微信小程序开发资源汇总](https://github.com/justjavac/awesome-wechat-weapp)

### 

#### 1、基本知识（着重部分）
##### [基础知识准备（参考教程）](https://www.jianshu.com/p/aaef5ceb3936)
##### 1.1、微信小程序中就四种类型的文件

  js ---------- JavaScrip文件（必须）  
  
  json -------- 项目配置文件，负责窗口颜色等等（必须）  
  
  wxml -------- 类似HTML文件  
  
  wxss -------- 类似CSS文件（必须）  

在根目录下用app来命名的这四中类型的文件，就是程序入口文件。


##### 1.2、生命周期

| 属性 | 类型 | 描述 |
| ----|:-----:|:-----:|
| data | Object | 页面的初始数据 |
| onLoad | function | 监听页面加载，一个页面只会调用一次 | 
| onReady | function | 监听页面初次渲染完成，一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互 | 
| onShow | function  | 每次打开页面都会调用一次 | 
| onHide | function | 监听页面隐藏，当navigateTo或底部tab切换时调用 | 
| onUnload | function | 监听页面卸载 ，当redirectTo或navigateBack的时候调用 | 
| onLaunch | function | 监听小程序初始化，当小程序初始化完成时，会触发 onLaunch（全局只触发一次） | 
| onError | function | 错误监听函数，当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息 | 

##### 1.3、配置
1.app.json :
	
```
    ”pages”: [] 设置页面路径
    “window”: { //设置默认窗口的表现(颜色都是十六进制的)
    “navigationBarBackgroundColor”: #000, //导航栏背景颜色
    “navigationBarTextStyle”: white/black, //导航栏标题颜色，仅支持black/white
    “navigationBarTitleText”: string, //导航栏标题
    “backgroundColor”: #fff, //窗口的背景颜色
    “backgroundTextStyle”: dark, //下拉背景字体、loading 图的样式，仅支持 dark/light
    “enablePullDownRefresh”: boolean //是否开启下拉刷新,详见页面相关事件处理函数。
    }
    “tabBar”: { //设置底部的tab
    “color”: #ddd, //tab上文字的默认颜色
    “selectedColor”: #333, //选中tab时的颜色
    “backgroundColor” #ccc, //tab背景颜色
    “borderStyle”: black/white, //tabBar上边框的颜色，仅支持black/white
    “list”: [ //tab 的列表
    {
    “pagePath”: ‘../..’, //pages中定义的页面路径
    “text”: string, //tab上的按钮文字
    “iconPath”: ‘../..’, //图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效
    “selectedIconPath”: ‘../..’ //选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效
    }
    ],
    “position”: top/bottom //
    }
    “networkTime”: { //网络超时时间
    “request”: 10 000, //wx.request 的请求超时时间，默认60 000(下面都是)
    “connectSocket”: 10 000, //wx.connectSocket的超时时间
    “uploadFile”: 10 000, //wx.uploadFile的超时时间
    “downloadFile”: 10 000, //wx.downloadFile的超时时间
    }
    “debug”: boolean 是否开启debug模式 
```
2.page.json :  
页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键。  
属性如下：
```
{
“navigationBarBackgroundColor”: #000,
“navigationBarTextStyle”: black/white,
“navigationBarTitleText”: string,
“backgroundColor”: #ddd,
“backgroundTextStyle”: dark/light,
“enablePullDownRefresh”: boolean,
“disableScroll”: boolean //设置为 true 则页面整体不能上下滚动；只在 page.json 中有效，无法在 app.json 中设置该项(默认 false )
}
```
3.app.js :  
开发工具会生成一个默认的程序框架，其中程序的主流程代码包含在app.js中。一般会用来设置全局变量，比如用户信息等。  

```
{
globalData:{    //定义需要传输的全局对象
    userInfo:null,    
    test:"test"    
}   

var test = getApp().globalData.test;  //获取  
console.log(test)   
```
4.app.wxss :  
app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。如果页面有自己的样式表， 则会覆盖公共样式表。  
```
.container {
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
  padding: 0rpx 0;
  box-sizing: border-box;
}
```

#### 2、函数定义
函数定义必须使用fun关键字，参数格式为 **参数: 类型**，如果有返回值，那么在函数的最后指明，例如：

```
fun sum(a: Int, b: Int) :Int {
	return a+b
}
```

#### 3、常量与变量

##### var：
可变变量，可读并且可写

```
var <标识符> : <类型> = <初始化值>
```

##### val：
不可变常量，只能赋值一次（类似Java中的final）

##### 常量与变量都可以没有初始化值,但是在引用前必须初始化

#### 4、NULL检查机制
又名Kotlin的空安全，这是Kotlin独有的，在对于声明可空的参数，在使用时要进行判空处理，有两种处理方式，字段后面加上!!，这样可以像Java那样如果为空就报空指针异常，还有一种是字段后加?，这样可以不做处理返回null或者配合?:（相当于Java中的三元运算）做判空处理：

```
//类型后面加?表示可为空
var age: String? = "23" 
//抛出空指针异常
val ages = age!!.toInt()
//不做处理返回 null
val ages1 = age?.toInt()
//age为空返回-1
val ages2 = age?.toInt() ?: -1

```

#### 5、条件判断
if和else的使用同Java一样，但是Java中的switch替换成了when，它既可以当作表达式使用，也可以当作语句使用：

```
val x=1
when(x){
	1 -> print("x==1")    第一个条件
	2 -> print("x==2")    第二个条件
	....
	else -> {     //最终（相当于switch的default）
		print("x==xxx")
	}
}

或者还可以这样用

val y=1
when(y){
	1,2 -> print("y==1 || y==2")  //多个分支有相同的处理方式时可以用逗号隔开统一处理
	else{
		print("x==xxx")
	}
}
```

#### 6、循环
while，do whie的使用方法和Java一样，唯一变的是for循环：

```
for (i in 1..5){
	print(i)   //输出为 1 2 3 4 5
}
//用 in .. 表示在某个区间，需要注意的是这里都是闭区间

//in .. 除了能在循环中用还能在条件判断中使用，例如
if (i in 1..5){
	//如果 1<=i<=5
}
if (i !in 1..5){
	//如果 i<1 || i>5
}

for (i in 5 downTo 1){
	print(i)  //输出为 5 4 3 2 1
}
//用 downTo表示逆序输出

for (i in 1..5 step 2){
	print(i)  //输出为 1 3 5
}
//用 step表示步长，相当于Java中的i+=2

for (i in 1 until 5){
	print(i)  //输出为 1 2 3 4
}
//用 until表示开区间
```

### 范型通配符

##### out：
在java中，有通配符和边界的概念比如Class<? extends T>，表示上界通配符，它代表T以及T的子类，上限是T；在kotlin中可以使用out来替代例如`clazz: Class<out T>`

##### in：
同样也有下届通配符比如<? super T>，它表示T以及T的超类，下限是T；在kotlin中可以使用in来代替例如`clazz: Class<in T>`


### 静态类和静态方法

##### object（全局）：
在java中，我们使用static来修饰类或者方法，标示该类或方法是静态方法，在kotlin中我们可以使用object来修饰类，这样我们就可以直接 **类名.方法** 名调用静态类中的方法了，但是不能用来修饰方法。

##### companion object（部分）：
在kotlin中，我们可以使用`companion object{}`来修饰方法：

```
companion object {
    fun start(context: Context) {
        FRStartActivity.start(context, MainActivity::class.java)
    }
}
```
这样这个方法就相当于java中的静态方法，我们可以直接使用 **类名.方法** 名来进行调用。

### 构造方法
构造方法分为主构造方法和次构造方法，主构造方法只能有一个，次构造方法可以有多个：

```
class Test(context: Context, flag: Int, string: String) {

    constructor(context: Context, flag: Int) : this(context, flag, "")

    constructor(context: Context, string: String) : this(context, 0, string)
}
```

1. 主构造函数在类头中申明，而次构造函数在类体中申明；
2. 主构造函数没有任何修饰符时可以省略constructor关键字，而次构造函数不能省略；
3. 主构造函数不能包含任何的代码，而次构造函数可以；
4. 主构造函数的参数可以在类体中的属性初始化代码和初始化块中使用，而次构造函数的参数不能；
5. 主构造函数中可以直接申明并初始化属性，而次构造函数不能直接申明属性；
6. 如果申明了主构造函数，那么所有的次构造函数都必需直接或间接地委托给主构造函数；
7. 非抽象类中如果没有声明任何构造函数，会生成一个不带参数的主构造函数，而不会生成任何次构造函数。


### 常见的操作符讲解

##### 1、`:`操作符
1.1、声明常量和变量的类型

```
var count:Int=0
val TAG:String="Main"
```
1.2、类的继承

```
//注意，在Kotlin中，所有的类都是不能直接被继承的，需要添加open关键字，open关键字
//和Java中的final关键字意义相反
class MainActivity : Activity(){
}
```
1.3、使用Java类

```
val intent=Intent(this,MainActivity::class.java)
```
##### 2、`?`操作符
`?`一般在某个对象或者方法后面添加，表示该对象或者方法可以为空。

```
var name:String?=null

fun name(str:String):Int?{
}

name?.length //如果name非空，那么返回name.length，否则返回null
```

##### 3、`?:`操作符
该操作符也称之为Elvis操作符，来看一下它的使用方法：

```
val length = name?.length ?: -1 
```
如果`?:`左侧表达式非空，那么就会返回其左边表达式的结果，否则返回右边的。

##### 4、`!!`操作符

```
val length=name!!.length
```
如果name为null，那么会宝空指针异常，否则会返回name的长度，它与`?`的区别在于它不允许为空，为空就报空指针异常。

##### 5、`as`与`as?`操作符
这两个操作符都是用来类型转换的，但是前者可能会出现类型转换出错，然后会报ClassCastException异常，后者当出现类型转换的错误时会返回null。

```
private lateinit var textView : TextView
private var imageView : ImageView? = null

textView = findViewById(R.id.xxx) as TextView
imageView = findViewById(R.id.xxx) as? ImageView

```

##### 6、`is`与`!is`操作符
这两个个操作符的使用和Java中的instanceof一样，用来判断某个实例是否属于某个类型

```
if (textView is View){
}
if (imageView !is TextView){
}
```

### 扩展函数
扩展函数数是指在一个类上增加一种新的行为，甚至我们没有这个类代码的访问权限。换句话说，我们可以给某个类进行扩展，在不改变原来类的基础上增加一些新的函数方便我们使用，比如：

```
fun Context.toast(message: CharSequence, duration: Int = Toast.LENGTH_SHORT) {
    Toast.makeText(this, message, duration).show()
}

fun String?.isEmpty() = this == null || length == 0
```
对于上述函数，Context和String是函数扩展的对象，也就是你要给谁增加函数；`.`表示扩展函数修饰符；toast和isEmpty为函数名。

### 内联函数

Java的方法执行需要压栈出栈，如果一个方法被多次调用，那么就需要多次的压栈出栈，为了节省这个操作，提高一定的效率，在kotlin中使用内联函数来拷贝你调用的方法，然后在你当前方法中使用。

##### 1.1、let函数

##### 1.2、with函数

##### 1.3、run函数

##### 1.4、apply函数

##### 1.5、also函数
