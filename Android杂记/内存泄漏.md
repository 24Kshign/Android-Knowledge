## 内存泄漏

### 1、定义

一个无用对象仍然被其他对象对象持有引用，造成该对象无法被系统回收，以致该对象在堆中所占用的内存单元无法被释放而造成内存空间的浪费，这就是内存泄漏。

### 2、在Android开发中，有哪些情况会发生内存泄漏？

##### 2.1 Context

我们都知道Activity的生命周期是比较短的，如果我们在一个生命周期更长的对象中引用了Activity的Context，那么在Activity销毁的时候内存就不会去回收Activity所占用的内存，因为它还在被使用，所以就回导致内存泄漏。

###### 解决办法：尽量使用Application的Context来代替Activity的Context。

##### 2.2 静态变量

静态变量存储在方法区，它的生命周期从类加载开始，到整个进程结束。一旦静态变量初始化之后，它所持有的引用只有等到进程结束之后才会释放，就会导致内存泄漏。

###### 解决办法：在用不到它的地方将其置空就好了。

##### 2.3 非静态内部类

非静态内部类默认持有外部类的引用，当非静态内部类对象的生命周期比外部类的生命周期长时，就会导致内存泄漏。

###### 解决办法：使用静态内部类来代替非静态，或者也可以将该类封装成一个单例。

##### 2.4 线程+Handler

在Activity中使用Handler的时候，Handler会自动与主线程Looper的MessageQueue关联起来，所有发送到MessageQueue的Message都持有Handler的引用，相当于间接的持有Activity的引用，而主线程的Looper对象会伴随该应用程序的整个生命周期，当Activity销毁之后，不能被回收。我们在Activity中使用线程的时候一般会使用匿名内部类，而匿名内部类也会对外部类持有默认的引用，当Activity关闭后如果线程中的任务还没执行完，也会导致Activity不能被回收，就会造成内存泄漏。

###### 解决办法：Handler的创建使用静态内部类的方式，然后适当的配合弱引用，最后在Activity销毁的时候remove掉消息；线程的话，创建一个静态内部类，实现Runnable接口，在使用的时候实例化它。

##### 2.5 资源未关闭

比如使用Bitmap的时候，使用数据库游标Cursor的时候，使用文件File的时候，等等这些都可能会造成内存泄漏。

###### 解决办法：在Activity销毁的时候，在适当的时候关闭或置空这些资源。

##### 2.6 未取消注册或回调

我们在Activity中注册广播时，如果不在Activity销毁时取消注册，那么这个广播就一直伴随应用程序，可能就会发生内存泄漏；使用观察者模式时如果不及时取消的话也会造成内存泄漏；使用RxJava的时候如果不在Activity销毁时取消绑定的话也会发生内存泄漏。

###### 解决方法：在需要取消的时候记得取消就行了。


